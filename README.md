# SPRING-DATA-JPA
- 순수 JPA와 비교하며 SPRING-DATA-JPA 공부하기 

## 프로젝트 개발 구성
- Java 8
- Spring Boot(+Gradle) 2.2.1
- H2(Embeded)
- SpringDataJPA
- JUnit5

## 추가 정리
- **SPRING-DATA-JPA란?**
  - SpringDataJPA는 기존 JPA의 기능에 SpringData의 기능을 추가하여 더욱 추상화 하여 좀 더 손쉽게 쓸 수 있도록한 Framework
------------
- **SPRING-DATA-JPA 장점**
  - 기본 (crud)메소드 추상화함으로 중복되는 코드가 간결해짐
    - EntityManager를 활용한 클래스 개발 안함 / JpaRepository를 상속받은 인터페이스만 만들면 됨
  - Query Method 및 추가기능(Paging ...)이 있어 코드가 간결해짐
------------
- **Query Method 3가지(1번과 3번만 실무에 사용하면 됨)**
  - **[실무 사용]** 메소드 이름으로 쿼리 생성
    - 장점 : 컴파일 시 에러 발견 가능
    - 장점 : 간편함 - 메소드명 작성만으로 저절로 쿼리 생성 
    - 단점 : 조건이 길어질 수록 메소드명이 너무 난잡해짐
  - @NamedQuery
    - 장점 : 컴파일시 에러 발견 가능
      - 순수 JPQL 사용시 컬럼명을 잘 못써도 호출까지 에러발견을 못하지만, @NamedQuery로 작성할 경우 컴파일에서 에러 발견 가능
    - 단점 : Entity에 쿼리 작성
  - **[실무 사용]** @Query
    - 장점 : 컴파일시 에러 발견 가능
    - 장점 : 2번(@NamedQuery)와 다르게 Entity에 쿼리 정의 안해도됨
------------
- **Binding** 
  - Parameter Binding
    - 위치 기반 
    - **[실무 사용]** 이름 기반 - 코드 가독성과 유지보수
      - 메소드 이름으로 쿼리 생성 
        - ex -> findByUsername
      - @Query 쿼리 생성 
        - ex -> m.username = :username / @Param("username") String username
  - Collection Binding
    - in 절
      - 메소드 이름으로 쿼리 생성 
        - ex -> findByUsernameIn
      - @Query 쿼리 생성 
        - ex -> m.username in :names / @Param("names") List<String> names
------------
- **Response Type**
  - [List(T), T, Optional(T), Page(T) ...] 자유로움(https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-return-types)
    - **[중요]** 대신 무조건 복수건과 단건 유의(IncorrectResultSizeDataAccessException)
  - **[중요]** NLP CHECK
    - List(T) 
      - ex -> if(members.size() == 0) 
    - T 
      - ex -> if(member == null)
    - Optional(T) 
      - ex -> if(memberOptional.isPresent() == false)
  - 순수 JPA 경우, NoResultException
------------
- **Paging**
  - 페이징과 정렬 파라미터 
    - Sort(T) - 정렬 기능
      - org.springframework.data.domain.Sort
    - Pageable(T) - 페이징 기능(정렬 포함) 
      - org.springframework.data.domain.Pageable
  - 특별한 반환 타입
    - Page(T) - 추가 count 쿼리 결과를 포함하는 페이징
      - org.springframework.data.domain.Page
      - DTO 변환 : page.map(T -> new T(...)
      - 보통 count 쿼리가 전체 조회이기 때문에 서비스 속도에 많은 영향을 끼침!!!
        - @Query(value="목록", countQuery="갯수") 이런 형식으로 구분지어 주는게 필수!!!!
    - Slice(T) - 추가 count 쿼리 없이 다음 페이지만 확인 가능(내부적으로 limit + 1조회)
      - org.springframework.data.domain.Slice
      - DTO 변환 : slice.map(T -> new T(...)
    - List(T)
      - 추가 count 쿼리 없이 결과만 반환
------------
- **BulkUpdate Query**
  - **[중요]** returnType : int / @Modifying 필수
  - 만약 한 트랜젝션이면 영속성 유지를 위하여, 꼭 BulkUpdate 이 후
    - EntityManager flush()/clear()
    - **[실무 사용]** @Modifying(clearAutomatically = true)
------------
- **@EntityGraph**     
  - **[중요]** FetchType.LAZY 경우 N+1 문제가 발생, 즉 추가 Query 발생
    - **[실무 사용]** @Query 사용 시 fetch 추가 
       - ex -> select m from Member m left join fetch m.team
    - **[실무 사용]** @EntityGraph(attributePaths = {})
       - ex -> @EntityGraph(attributePaths = {"team"})
    - @NamedEntityGraph Entity 추가 
       - ex -> @NamedEntityGraph(name = "Member.all", attributeNodes = @NamedAttributeNode("team"))
------------
- **JPA Hint**
  - **[중요]** 영속성 객체의 값을 변경하였을 경우, 저절로 Update되는 경우를 방지하기 위하여 readOnly 명시
  - @QueryHints(value = @QueryHint(name = "org.hibernate.readOnly", value="true"))
------------
- **JPA Lock**
  - Select For Update
  - 트래픽이 많은 서비스에서는 왠만하면 안씀, 나중에 꼭 공부해 볼 것!
------------
- **Custom Repository**
  - 스프링 데이터 JPA 리포지토리는 인터페이스만 정의하고 구현체는 스프링이 자동 생성
  - 스프링 데이터 JPA가 제공하는 인터페이스를 직접 구현하면 구현해야 하는 기능이 너무 많음
  - 다양한 이유로 인터페이스의 메서드를 직접 구현하고 싶다면?
    - JPA 직접 사용( EntityManager )
    - 스프링 JDBC Template 사용
    - MyBatis 사용
    - 데이터베이스 커넥션 직접 사용 등등...
    - **[실무 사용]** Querydsl 사용
  - 설정 방법
    1. [Custom Repository] interface 생성
    2. [Custom Repository] class 생성 실질적 구현부 작성
      - **[중요]** class 명명 규칙 = 기존Repository+Impl || 커스텀Interface+Impl
        - ex -> MemberRepositoryImpl || MemberRepositoryCustomImpl
      - Impl 말고 다른 것을 사용하고 싶을 시, 아래 추가
        - XML 
          - '<'repositories base-package="study.datajpa.repository" repository-impl-postfix="Impl" />
        - JavaConfig
          - @EnableJpaRepositories(basePackages = "study.datajpa.repository",repositoryImplementationPostfix = "Impl")
    3. JpaRepository 상속부에 interface 추가 상속
      - ex -> public interface MemberRepository extends JpaRepository<Member, Long>, MemberRepositoryCustom{
------------
- **Auditing**
  - Entity 생성,변경할 때 변경한 사람과 시간 추적
  - 설정 방법
    - 순수 JPA
      1. Base Entity class 생성 
         - **[참조]** me.study.datajpa.entity.JpaBaseEntity.java 
      2. 사용할 Entity class에서 상속
    - Spring-Data-JPA
      1. @EnableJpaAuditing - 스프링 부트 설정 클래스에 적용해야함
         - **[참조]** me.study.datajpa.DataJpaApplication.class
      2. @EntityListeners(AuditingEntityListener.class)
         - **[참조]** me.study.datajpa.entity.BaseTimeEntity.java
         - **[참조]** me.study.datajpa.entity.BaseEntity.java
      3. 사용할 Entity class에서 상속
  - 계정 정보를 넣고 싶을 경우
    - 등록자/수정자를 처리해주는 AuditorAware 스프링 빈 등록
      - **[참조]** me.study.datajpa.DataJpaApplication.class
------------
- **[Web 확장] Domain Converter**
  - 스프링 데이터 JPA가 자동으로 DB에서 매핑
  - **[참조]** me.study.datajpa.controller.MemberController.java
  - **[중요]** 기능은 존재하지만 쓰지말자!!!
    - 트랜젝션이 없는 상태에서 조회되므로 영속성 유지가 안된 상태
------------
- **[Web 확장] Paging & Sort**
  - 스프링 데이터 JPA가 자동으로 PageRequest를 생성하여 매핑
  - 파라미터 ex -> /members?page=0&size=3&sort=id,desc&sort=username,desc
    - page
    - size
    - sort
  - Default 값 변경
    - 글로벌일 경우, yml 변경 
      - spring.data.web.pageable.default-page-size=20 /# 기본 페이지 사이즈/
      - spring.data.web.pageable.max-page-size=2000 /# 최대 페이지 사이즈/
    - 개별일 경우,  @PageableDefault 추가
      - **[참조]** me.study.datajpa.controller.MemberController.java
  - **[중요]** Page(Entity) -> Page(DTO) 변경
    - ex -> memberRepository.findAll(pageable).map(m -> new MemberDto(m.getId(), m.getUsername(), null))
      - **[참조]** me.study.datajpa.controller.MemberController.java
------------
- **[기능 심화] 새로운 Entity인지 판별하는 법?**
  - 식별자가 객체일 때 null 로 판단
  - 식별자가 자바 기본 타입일 때 0 으로 판단
  - **[중요]** 하지만 !!!!
    - 문제점 
      - 식별자가 보통 쓰는 @Id @GeneratedValue Long id이 아니고 @Id String id 일 경우(식별자를 강제로 주는 경우),  
        pk값이 존재하기 하기 때문에 persist()가 아닌 merge()로 사용.  
        즉, select -> insert 2번의 쿼리가 발생
    - 해결방법
      - Persistable 인터페이스를 구현해서 판단 로직 변경 가능
        - 해당 Entity에 Persistable<T>를 상속받아 isNew() 메소드를 오버라이드하여 신규 Entity인지 커스텀
        - **[실무 사용]** [Auditing]에서 추가한 생성일이 == null로 파악
          - **[참조]** me.study.datajpa.repository.Item.java